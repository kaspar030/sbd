use std::{
    collections::{BTreeMap, HashSet},
    default::Default,
    str::FromStr,
};

use anyhow::{Result, anyhow};
use camino::{Utf8Path, Utf8PathBuf};

#[derive(Debug, Clone, PartialEq, Eq, Default)]
pub struct FileMap {
    map: BTreeMap<Utf8PathBuf, String>,
    tagfile: Option<Utf8PathBuf>,
}

impl FileMap {
    pub fn new() -> Self {
        Self {
            tagfile: Some(Utf8PathBuf::from(".sbd-gen")),
            ..Self::default()
        }
    }

    pub fn write_all(&self, outpath: &Utf8Path) -> Result<()> {
        for (file, content) in &self.map {
            let file_path = outpath.join(file);
            if let Some(parent) = file_path.parent() {
                std::fs::create_dir_all(parent)?;
            }
            std::fs::write(file_path, content)?;
        }

        if let Some(tagfile) = &self.tagfile {
            std::fs::write(
                outpath.join(tagfile),
                "The contents of this directory were generated by sbd-gen.",
            )?;
        }

        Ok(())
    }

    pub fn compare(&self, outpath: &Utf8Path) -> Result<CompareResult> {
        use walkdir::WalkDir;
        let mut missing = Vec::new();
        let mut changed = Vec::new();
        let mut extra = Vec::new();
        let mut all = HashSet::new();

        for entry in WalkDir::new(outpath) {
            let entry = entry?;
            if entry.file_type().is_file() {
                let file_path =
                    Utf8PathBuf::from_path_buf(entry.path().to_path_buf()).map_err(|_| {
                        anyhow::anyhow!("non-utf8 file path: \"{}\"", entry.path().display())
                    })?;

                let map_file_path = file_path.strip_prefix(outpath)?;
                all.insert(map_file_path.into());

                if let Some(content) = self.map.get(map_file_path) {
                    fn contents_match(file_path: &Utf8Path, content: &str) -> Result<bool> {
                        let entry_content = std::fs::read_to_string(file_path)?;
                        // TODO: hash?
                        Ok(entry_content == content)
                    }

                    if entry.metadata()?.len() == content.len() as u64
                        && contents_match(&file_path, content)?
                    {
                        // same
                    } else {
                        changed.push(map_file_path.into());
                    }
                } else if self
                    .tagfile
                    .as_ref()
                    .is_none_or(|tagfile| map_file_path != tagfile)
                {
                    extra.push(file_path);
                }
            }
        }

        self.map
            .keys()
            .cloned()
            .collect::<HashSet<_>>()
            .difference(&all)
            .for_each(|file| {
                missing.push(file.to_owned());
            });

        Ok(CompareResult {
            missing,
            extra,
            changed,
        })
    }

    pub(crate) fn insert(&mut self, from: Utf8PathBuf, manifest_content: String) {
        self.map.insert(from, manifest_content);
    }

    pub(crate) fn tagfile(&self) -> Option<Utf8PathBuf> {
        self.tagfile.clone()
    }

    pub(crate) fn extend_subdir(&mut self, name: &Utf8Path, files: FileMap) {
        let subdir = Utf8PathBuf::from(&name);

        for (file, content) in files.map {
            let full_path = subdir.join(file);
            self.insert(full_path, content);
        }
    }
}

#[derive(Debug, Clone, Copy, Default, PartialEq)]
pub enum Mode {
    #[default]
    Create,
    Update,
    Check,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CompareResult {
    pub missing: Vec<Utf8PathBuf>,
    pub extra: Vec<Utf8PathBuf>,
    pub changed: Vec<Utf8PathBuf>,
}
impl CompareResult {
    fn is_same(&self) -> bool {
        self.missing.is_empty() && self.extra.is_empty() && self.changed.is_empty()
    }
}

impl Mode {
    pub fn apply(self, outpath: &Utf8Path, filemap: &FileMap) -> Result<()> {
        let tagfile = filemap.tagfile();

        // 1. create never overwrites
        // 2. update only overwrites if there is a tagfile
        if outpath.exists() {
            match self {
                Mode::Create => {
                    return Err(anyhow!(
                        "Directory already exists and is non-empty. Try `update` mode."
                    ));
                }
                Mode::Update => {
                    if let Some(ref tagfile) = tagfile {
                        let tagfile_path = outpath.join(tagfile);
                        if !tagfile_path.exists() {
                            return Err(anyhow!(
                                "Refusing to update directory without containing `{tagfile}`."
                            ));
                        }
                    }
                }
                Mode::Check => {}
            }
        }

        match self {
            Mode::Create => filemap.write_all(outpath)?,
            Mode::Check => {
                let res = filemap.compare(outpath)?;
                if !res.is_same() {
                    for missing_file in res.missing {
                        println!("missing: {missing_file}");
                    }
                    for extra_file in res.extra {
                        println!("extra: {extra_file}");
                    }
                    for changed_file in res.changed {
                        println!("changed: {changed_file}");
                    }
                    return Err(anyhow!(
                        "Directory `{outpath}` is not up-to-date. Try `update` mode."
                    ));
                }
            }
            Mode::Update => {
                let res = filemap.compare(outpath)?;
                for file in res.extra {
                    std::fs::remove_file(file)?;
                }
                filemap.write_all(outpath)?;
            }
        }
        Ok(())
    }
}

impl FromStr for Mode {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "create" => Ok(Mode::Create),
            "update" => Ok(Mode::Update),
            "check" => Ok(Mode::Check),
            _ => Err(format!("Invalid mode: {s}")),
        }
    }
}

pub fn parse_mode(s: &str) -> Result<Mode, String> {
    Mode::from_str(s)
}
